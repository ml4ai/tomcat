#!/bin/bash

set -u

# =============================================================================

# Set the TOMCAT environment variable, assuming that the directory structure
# mirrors that of the git repository.
TOMCAT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../" >/dev/null 2>&1 && pwd)"
export TOMCAT
save_dir="${TOMCAT}/external/malmo/Minecraft/run/saves"

source "$TOMCAT"/tools/configuration_helpers

configure_session

# If the above fails, we do not get here. 

# Start mosquitto message broker if it is not already running.
if [[ ! $(pgrep -l mosquitto | head -n1 | cut -d' ' -f2) == mosquitto ]]; then
    mosquitto &
fi


# This function returns the date and time in the current timezone.
timestamp() {
  date "+%Y_%m_%d_%H_%M_%S"
}

# On macOS, uuidgen produces uppercase UUIDs, so we pipe the output through tr
# to get uniform behaviour on macOS and Linux.
session_uuid=$(uuidgen | tr '[:upper:]' '[:lower:]')
if [[ $? -ne 0 ]]; then exit 1; fi

# Creating an output directory for this session.
session_output_dir="${TOMCAT}"/data/participant_data/"$session_uuid"
mkdir -p "${session_output_dir}"

# Generate metadata file for the session
"$TOMCAT"/tools/generate_session_metadata "$session_uuid" > "$session_output_dir"/metadata.json
if [[ $? -ne 0 ]]; then exit 1; fi


start_ffmpeg_recording() {
    echo "Recording video of player's face using webcam."
    ffmpeg\
    -f ${FFMPEG_FMT_WEBCAM}\
    ${FRAMERATE_OPTION:-}\
    -i ${FFMPEG_INPUT_DEVICE_WEBCAM}\
    -r 30\
    "${MISSION_OUTPUT_DIR}"/webcam_video.mpg\
    &> ${TOMCAT_TMP_DIR}/ffmpeg_webcam_mission_"$CURRENT_MISSION".log &
    
    echo "Recording player audio using microphone."
    ffmpeg\
    -nostdin\
    -f ${FFMPEG_FMT_MICROPHONE}\
    -i ${FFMPEG_INPUT_DEVICE_MICROPHONE}\
    "${MISSION_OUTPUT_DIR}"/player_audio.wav\
    &> ${TOMCAT_TMP_DIR}/ffmpeg_microphone_mission_"$CURRENT_MISSION".log &

    if (( ENABLE_SYSTEM_AUDIO_RECORDING )); then
        echo "Recording system audio."
        ffmpeg\
        -nostdin\
        -f ${FFMPEG_FMT_SYSTEM_AUDIO}\
        -i ${FFMPEG_INPUT_DEVICE_SYSTEM_AUDIO}\
        "${MISSION_OUTPUT_DIR}"/system_audio.wav\
        &> "$TOMCAT_TMP_DIR"/system_audio_recording_mission_"$CURRENT_MISSION".log &
    fi

    # Recording game screen.
    echo "Recording player's screen."
    screen_video="${MISSION_OUTPUT_DIR}"/screen_video.mpg
    ffmpeg -nostdin -f ${FFMPEG_FMT_SCREEN_CAPTURE}\
    -i ${FFMPEG_INPUT_DEVICE_SCREEN_CAPTURE}\
    -s $SCREEN_DIMENSIONS\
    "$screen_video" &> "$TOMCAT_TMP_DIR"/screen_video_recording_mission_"$CURRENT_MISSION".log &
}

# Function to cleanup things on exit or keyboard interrupt.
cleanup() {
    cleanup_status=0 

    echo "Script run_session is cleaning up." 

    if (( ENABLE_FFMPEG )); then pkill ffmpeg; fi

    # Kill any remaining mosquitto, mosquitto_sub, and mosquitto_pub processes
    pkill mosquitto

    if [[ ${RECYCLE_MINECRAFT} -lt 2 ]]; then
        if ! "${TOMCAT}/tools/kill_minecraft"; then cleanup_status=1; fi
    fi

    if [[ $CI -eq 0  \
          && $ENABLE_SYSTEM_AUDIO_RECORDING -eq 1 \
          && "$OSTYPE"  == "darwin"* ]]; then
        
        # Switching the audio output from the multi-output device to the
        # built-in output.
        if ! SwitchAudioSource -s "$ORIGINAL_OUTPUT_DEVICE"; then
            echo " "
            echo "Failed to switch audio output device back to what it was"\
                 "before run_session (${ORIGINAL_OUTPUT_DEVICE})."
            echo " "
            cleanup_status=1
        fi
    fi

    exit ${cleanup_status}
}


# A function to handle cleanup when a user interrupts the script with Ctrl+C
user_interrupt() {
    echo "Detected keyboard interrupt."
    echo "Cleaning up now"
    cleanup
    exit 1
}

trap user_interrupt SIGINT SIGTERM



do_mission() {
    export CURRENT_MISSION="$1"
    echo " "
    echo "Running mission ${CURRENT_MISSION} in ${TOMCAT}."
    echo " "
    mission_log="$TOMCAT_TMP_DIR"/mission_"$CURRENT_MISSION".log
    export MISSION_OUTPUT_DIR="${session_output_dir}"/mission_"$CURRENT_MISSION"
    mkdir -p "$MISSION_OUTPUT_DIR"
    malmo_data="$MISSION_OUTPUT_DIR"/malmo_data.txt
    event_data="$MISSION_OUTPUT_DIR"/events.txt
    self_report_data="$MISSION_OUTPUT_DIR"/self_reports.txt

    # Kobus: Other mechanisms are in place that now mean we might not want to do
    # a second try. So, let's test with num_tries=1, and if this works out, we
    # can clean the loop. 
    num_tries=1
    try=0


    while [ $try -lt $num_tries ]; do
        if ! "${TOMCAT}"/tools/check_minecraft; then
            echo "Main mission cannot find or create a viable Minecraft process."
            cleanup
            exit 1  
        fi 

        runExperiment_args="--mission ${CURRENT_MISSION} --record_observations --uuid ${session_uuid}"

        if [[ $CURRENT_MISSION -gt 0 ]]; then
            runExperiment_args="${runExperiment_args} --time_limit ${TIME_LIMIT}"
        fi

        if (( ENABLE_FFMPEG )); then
            start_ffmpeg_recording
        fi
        # Publish the Malmo observation messages to the message bus on the
        # topic observations/state.
        "${TOMCAT}"/build/bin/runExperiment\
        $runExperiment_args\
        2> "${mission_log}"\
        | mosquitto_pub -t observations/state -l &
        pid_runExperiment=$!

        # Subscribe to the observations/state topic on the message bus and
        # redirect the output to a file.
        mosquitto_sub -t observations/state > "$malmo_data" &
        pid_observations_state=$!
        mosquitto_sub -t "observations/events/#" > "$event_data" &
        pid_observations_events=$!
        mosquitto_sub -t observations/self_reports > "$self_report_data" &
        pid_observations_self_reports=$!

        if [[ $CURRENT_MISSION -gt 0 ]]; then
            echo "Time limit set to ${TIME_LIMIT}."
        fi
        echo "Process ID corresponding to ./bin/runExperiment is"\
             "$pid_runExperiment ... waiting for it to complete."

        # Set up a background job to kill the mission if Minecraft dies.
        ${TOMCAT}/tools/kill_me_if_no_minecraft $pid_runExperiment < /dev/null & 

        wait $pid_runExperiment
        mission_status=$?

        if [[ ${mission_status} -eq 0 ]]; then
            mission_status=$(grep -c "Error starting mission" "${mission_log}")
        fi

        if [[ ${mission_status} -eq 0 ]]; then
            kill $pid_observations_state
            kill $pid_observations_events
            kill $pid_observations_self_reports
            echo "Mission ${CURRENT_MISSION} ended with exit code 0."
            echo "All recorded data is in ${MISSION_OUTPUT_DIR}"
            echo " "
            break
        fi

        (( try++ ))

        if [[ $try -lt $num_tries ]]; then
            echo "Mission ${CURRENT_MISSION} ended with exit code 1."
            echo "Killing all Minecraft and Malmo processes that can be found"
            echo "and trying again."

            if [[ ${RECYCLE_MINECRAFT} -lt 1 ]]; then
                "$TOMCAT"/tools/kill_minecraft
            fi 
        fi
    done
}

echo TOMCAT_DEBUG_ECHO: $TOMCAT_DEBUG_ECHO
if (( DO_TUTORIAL_MISSION )); then
    do_mission 0
else
    ${TOMCAT_DEBUG_ECHO} "Skipping tutorial because DO_TUTORIAL_MISSION=0"
fi

if [[ $DO_TUTORIAL_MISSION -eq 1 && $DO_MAIN_MISSION -eq 1 ]]; then
    # We sleep for a few seconds to let the player catch a breath between the
    # tutorial and main missions.
    sleep 6
fi

if (( DO_MAIN_MISSION )); then do_mission ${MAIN_MISSION}; fi


echo "Finished running all sessions in ${TOMCAT}."
echo "Doing our final cleanup."

# If we are here, then we do not have any errors. Probably will need to upgrade
# at some point to possibly get here even with errors. But right now, if we have
# an error above, we call cleanup and exit. 

cleanup
