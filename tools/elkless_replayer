#!/usr/bin/env python3

# Author: Adarsh Pyarelal (adarsh@arizona.edu)

""" ELKless Replayer is a simple program to replay messages from a file
containing messages collected during a TA3 experimental trial and dumped from
an Elasticsearch database.

For each line in the input file, it extracts the JSON-serialized message and
the topic it was published to, and republishes the message to the same
topic."""

# Requires the python-dateutil package.
# To see the command line arguments and invocation pattern, run
#     ./elkless_replayer -h

import json
from dateutil.parser import parse
import argparse
import paho.mqtt.client as mqtt

mqttc = mqtt.Client()

if __name__ == "__main__":

    # Argument parsing
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("input", help="The messages file to replay to the bus")
    parser.add_argument(
        "-m",
        "--host",
        help="Host that the mosquitto message broker is running on.",
        default='localhost',
    )
    parser.add_argument(
        "-p",
        "--port",
        type=int,
        help="Port that the mosquitto message broker is running on.",
        default=1883,
    )
    args = parser.parse_args()

    # Open the input file, parse each line in it as a JSON-serialized object.
    with open(args.input, "r") as f:
        messages = []
        for line in f:
            # print(line)
            jline = None
            try:
                jline = json.loads(line)
            except:
                print('bad json line of len: {}, {}'.format(len(line), line))
            if jline is not None:
                messages.append(jline)

        sorted_messages = sorted(messages, key=lambda x: parse(x['header']['timestamp']))
        print('publishing message count {}'.format(len(sorted_messages)))
        # pub_via_shell(sorted_messages)
        mqttc.connect(args.host, port=args.port)

        for data in sorted_messages:
            # Delete keys that were not in the original message, for more
            # faithful replaying.
            for key in ("message", "@timestamp", "@version", "host"):
                if key in data:
                    del data[key]

            # Get the topic to publish the message to.
            topic = data.pop("topic")
            mqttc.publish(topic, json.dumps(data))
        mqttc.loop(timeout=1.0)
        # Now we should have really pushed all the messages.
