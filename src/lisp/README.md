SAR PDDL Domains/Lisp files
===========================
The folder contains all files pertaining to our Search and Rescue planning domains as well as 
our efforts to create a plan recognition algorithm. The main files required for running the domains 
and problem definitions are in Common Lisp (using the .lisp extension).
There are also other minor files serving as data and utility files as well
python code for data manipulation and experiments related to plan recognition and prediction.

To run the domain files (and any .lisp files), it is assumed that you have Common Lisp (preferably
Steel Bank Common Lisp) installed along with quicklisp and SHOP3. 

The SAR Individual Domain
-------------------------
The Search and Rescue individual planning domain is written in a file called `sar-individual-domain.lisp` using the SHOP3 common
Lisp library. Along with the domain file there are two other lisp files
`sar-individual-test-prob.lisp` and `sar-individual-test-prob-grapher.lisp`
which are scripts that set-up a SAR domain problem definition and call on
`sar-individual-domain.lisp` to generate plan trees using SHOP3. 

`sar-individual-test-prob.lisp` can be called from the command line by with the
following command,

`sbcl --load sar-individual-test-prob.lisp --quit`

This currently generates a txt file, `sar-plan-trees.txt`, which contains a
plan tree for an agent executing a Yellow First Triaging Strategy. The plan
tree is represented as a list of lists data structure using Common Lisp
S-expressions. 

Similarly, `sar-individual-test-prob-grapher.lisp` can be called using the
command,

`sbcl --load sar-individual-test-prob-grapher.lisp --quit`

This generates a pdf file, `sar-graph.pdf`, which contains a graphical
visulization of the same plan tree generated by
`sar-individual-test-prob.lisp`.

Plan trace generation
---------------------
The `plan_trace_generation` folder contains code for generating plan traces
(state and action sequences) from the SAR Individual Domain. It contains a
python class called PTTrees which is designed to store plan trace trees
produced from SHOP3 domains. The plan trace tree has constructors for creating
a tree from json objects/python dictonaries as well as list s-expressions (in
string form). SHOP3 plans can have recursive tasks that represent task looping,
the PTTree has a function that detects this type of recursion and remove the
recursive tasks so that the plan trees represent the loops. The plan trace
trees can be dumped into a JSON format.  

Using the PTTree class, there is a script capable of parsing domain outputs and
creating a list of plan trees and dumping the list into a JSON file. This script is 
found in the `plan_trace_generation`.

The first step is to generate domain output in a text file. The planning domain
must have specific objects traced and have the find plans function set to
produce plan trees. See the top of `simple-sar-domain.lisp` where the shop
trace is called and the bottom of the file where the find plans function is
called. Here is an example of producing domain output from an appropriate
domain,

`sbcl --load simple-sar-domain.lisp --quit > simple-sar-plans.txt`

After the parser can be ran on the txt file produced,

`python plan_trace_parser.py <domain definition file>.lisp <name of output file>.json`

Ex:

`python plan_trace_parser.py simple-sar-domain.txt simple-sar-plan-trees.json`

Message Conversion Code
-----------------------
`message-conversion.lisp` is a Common Lisp script that simulates converting
json messages from the message bus into SHOP3 state predicates. To run you must
first have downloaded a `<experiment>_messages.json` file to this folder and
have mosquitto, a MQTT message broker. There is also a `elkless_replayer` file in the `tomcat/tools` directory that
simulates message publishing from the message bus, which is a python script and
requires the "paho-mqtt" module (i.e, run `pip install paho-mqtt`).

Assuming you have the proper files and set-up, you can then run the commands,

`sbcl --load message-conversion.lisp --eval '(initialize-current-goal
"sar-individual-example-goal.txt")' --quit`

`mosquitto_sub -t observations/events/player/triage | sbcl --load
message-conversion.lisp --eval '(listen-for-messages)' --quit`

This will create a fresh goal state txt file `sar-individual-current-goal.txt` 
copied from `sar-individual-example-goal.txt` and start the message listener and
feed the incoming messages to the message conversion script. To simulate
messages being published from the message bus, first open another terminal
window and change to the `tomcat/tools` directory and then run,

`./elkless_replayer ../src/lisp/<experiment>_messages.json`

Back in this directory (`tomcat/src/lisp`) you will see that
`sar-individual-current-goal.txt` now includes predicate statements converted
from the json messages.  

Domain Element Parser
----------------------
The `domain-element-parser.py` file is a script that can take a SHOP3 domain
definition file (with .lisp extension) and extract the headers of the main elements (types,
predicates, actions, compound tasks, methods) from it into a JSON file. 

This can simply be ran by doing,

`python domain-element-parser.py <domain definition file>.lisp <name of output file>.json`

Ex:

`python domain-element-parser.py sar-individual-domain.lisp
sar-individual-domain-elements.json`

Note: The parser requires certain format conventions in the domain definition
file, please look `sar-individual-domain.lisp` as an example of these
conventions. 

PDDL2JSON
----------
This is like the Domain Element Parser except that it does a far more
complete parsing that converts the PDDL/lisp domain into a json format.

This can be ran by doing,

`python pddl2json.py <domain definition file>.lisp <name of output file>.json`

Ex:

`python pddl2json.py simple-sar-domain.lisp simple-sar-domain.json`

Note: The parser requires certain format conventions in the domain definition
file, please look `simple-sar-domain.lisp` as an example of these
conventions. 

Plan Recognition
-----------------
A juptyer notebook demo can be ran in the `plan_recognition` folder. This demo
along with requiring you to be able to run a jupyter notebook also
requires that `simple-schedule-plan-traces.json` be generated first. This json
file can be generated by running,

`make`

or

`make simple-schedule-plan-traces.json`

in the `plan_recognition` folder. After generating the needed file, you may
open the jupyter notebook and run the demo. If you cannot run the demo, you can
see a fully ran demo here
`https://drive.google.com/file/d/183LM5rscUDFpdIdGutY8ueQaJstmy0f5/view?usp=sharing`
