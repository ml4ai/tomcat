#pragma once

#include "DynamicBayesNet.h"

namespace tomcat {
    namespace model {

        /**
         * Abstract representation of a class to generate samples from a DBN
         * model.
         */
        class Sampler {
          public:
            //------------------------------------------------------------------
            // Constructors & Destructor
            //------------------------------------------------------------------
            Sampler();

            Sampler(DynamicBayesNet model,
                    std::shared_ptr<gsl_rng> random_generator);

            virtual ~Sampler();

            //------------------------------------------------------------------
            // Copy & Move constructors/assignments
            //------------------------------------------------------------------

            // Copy constructor and assignment should be deleted to avoid
            // implicit slicing and loss of polymorphic behaviour in the
            // subclasses. To deep copy, the clone method must be used.
            Sampler(const Sampler&) = delete;

            Sampler& operator=(const Sampler&) = delete;

            Sampler(Sampler&&) = default;

            Sampler& operator=(Sampler&&) = default;

            //------------------------------------------------------------------
            // Member functions
            //------------------------------------------------------------------

            /**
             * Adds data to a specific node.
             *
             * @param node_label: node's label
             * @param data: observed values for the node over time. Data should
             * be a matrix of dimension (num_data_points, time_steps)
             */
            void add_data(std::string& node_label, Eigen::MatrixXd& data);

            /**
             * Adds data to a specific node.
             *
             * @param node_label: node's label
             * @param data: observed values for the node over time. Data should
             * be a matrix of dimension (num_data_points, time_steps).
             */
            void add_data(std::string&& node_label, Eigen::MatrixXd&& data);

            /**
             * Returns samples generated for a specific latent node.
             *
             * @param node_label: latent node label
             * @return Samples over time. A matrix of dimension (num_samples,
             * time_steps).
             */
            const Eigen::MatrixXd&
            get_samples(const std::string& node_label) const;

            /**
             * Saves generated samples to files in a specific folder.
             * @param output_folder: folder where the files should be saved.
             */
            void save_samples_to_folder(const std::string& output_folder) const;

            //------------------------------------------------------------------
            // Pure virtual functions
            //------------------------------------------------------------------

            /**
             * Generates samples for the latent nodes
             *
             * @param num_samples: number of samples to generate
             * @param time_steps: number of time steps the model should be
             * unrolled into
             */
            virtual void sample(int num_samples, int time_steps) = 0;

            /**
             * Clones a sampler
             *
             * @return Pointer to the new sampler.
             */
            virtual std::unique_ptr<Sampler> clone() = 0;

          protected:
            //------------------------------------------------------------------
            // Data members
            //------------------------------------------------------------------
            std::shared_ptr<gsl_rng> random_generator;
            DynamicBayesNet model;

            // Mapping between a node's label and data (observed values over
            // time). The data matrix has dimension (num_data_points,
            // time_steps).
            std::unordered_map<std::string, Eigen::MatrixXd> node_to_data;

            // Mapping between a node's label and samples generated by a
            // sampler. The samples matrix has dimension (num_samples,
            // num_time_steps).
            std::unordered_map<std::string, Eigen::MatrixXd> node_to_samples;

            // Nodes which values are not observed, i.e., nodes which samples
            // will be generated for.
            std::unordered_set<std::string> latent_node_labels;

            /**
             * Check whether the number of data points is consistent with the
             * number of samples. If there's a single data point, then it's values over time
             * are going to be considered in all the samples generated. If
             * there are as many data points as the number of samples requested,
             * then for each new sample, a new data point will be considered.
             * Otherwise, samples cannot be generated as it's impossible to tell
             * how the data points should be broadcasted or associated to each
             * one of the samples to be generated.
             *
             * @param num_samples: number of samples to be generated
             */
            void check_data(int num_samples) const;

            /**
             * Creates a matrix of dimension (num_samples, time_steps) for each
             * one of the latent nodes in the model and adds it to the
             * node_to_samples mapping.
             *
             * @param num_samples: number of samples to generate
             * @param time_steps: number of time steps the model will be
             * unrolled into
             */
            void init_samples_matrix(int num_samples, int time_steps);
        };
    } // namespace model
} // namespace tomcat