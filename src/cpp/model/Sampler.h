#pragma once

#include "DynamicBayesNet.h"
#include "Tensor3.h"

namespace tomcat {
    namespace model {

        /**
         * Abstract representation of a class to generate samples from a DBN
         * model.
         */
        class Sampler {
          public:
            //------------------------------------------------------------------
            // Constructors & Destructor
            //------------------------------------------------------------------
            Sampler();

            Sampler(DynamicBayesNet model,
                    std::shared_ptr<gsl_rng> random_generator);

            virtual ~Sampler();

            //------------------------------------------------------------------
            // Copy & Move constructors/assignments
            //------------------------------------------------------------------

            // Copy constructor and assignment should be deleted to avoid
            // implicit slicing and loss of polymorphic behaviour in the
            // subclasses. To deep copy, the clone method must be used.
            Sampler(const Sampler&) = delete;

            Sampler& operator=(const Sampler&) = delete;

            Sampler(Sampler&&) = default;

            Sampler& operator=(Sampler&&) = default;

            //------------------------------------------------------------------
            // Member functions
            //------------------------------------------------------------------

            /**
             * Adds data to node of arbitrary sample size.
             *
             * @param node_label: node's label
             * @param data: observed values for the node over time. Data should
             * be a tensor of dimensions (sample_size, num_data_points,
             * time_steps)
             */
            void add_data(std::string& node_label, Tensor3& data);

            /**
             * Adds data to node of arbitrary sample size.
             *
             * @param node_label: node's label
             * @param data: observed values for the node over time. Data should
             * be a matrix of dimensions (sample_size, num_data_points,
             * time_steps).
             */
            void add_data(std::string&& node_label, Tensor3&& data);

            /**
             * Returns samples generated for a specific latent node.
             *
             * @param node_label: latent node label
             * @return Samples over time. A matrix of dimension (num_samples,
             * time_steps).
             */
            const Tensor3&
            get_samples(const std::string& node_label) const;

            /**
             * Saves generated samples to files in a specific folder.
             * @param output_folder: folder where the files should be saved.
             */
            void save_samples_to_folder(const std::string& output_folder) const;

            //------------------------------------------------------------------
            // Pure virtual functions
            //------------------------------------------------------------------

            /**
             * Generates samples for the latent nodes
             *
             * @param num_samples: number of samples to generate
             * @param time_steps: number of time steps the model should be
             * unrolled into
             */
            virtual void sample(int num_samples, int time_steps) = 0;

            /**
             * Clones a sampler
             *
             * @return Pointer to the new sampler.
             */
            virtual std::unique_ptr<Sampler> clone() = 0;

          protected:
            //------------------------------------------------------------------
            // Data members
            //------------------------------------------------------------------
            std::shared_ptr<gsl_rng> random_generator;
            DynamicBayesNet model;

            // Mapping between a node's label and its metadata.
            std::unordered_map<std::string, NodeMetadata> node_label_to_metadata;

            // Mapping between a node's label and data (observed values over
            // time). The data tensor has dimension (sample_size,
            // num_data_points, time_steps).
            std::unordered_map<std::string, Tensor3> node_label_to_data;

            // Mapping between a node's label and samples generated by a
            // sampler. The samples matrix has dimension (sample_size,
            // num_samples, num_time_steps).
            std::unordered_map<std::string, Tensor3> node_label_to_samples;

            // Nodes which values are not observed, i.e., nodes which samples
            // will be generated for.
            std::unordered_set<std::string> latent_node_labels;

            /**
             * Check whether the number of data points is consistent with the
             * number of samples. If there's a single data point, then it's
             * values over time are going to be considered in all the samples
             * generated. If there are as many data points as the number of
             * samples requested, then for each new sample, a new data point
             * will be considered. Otherwise, samples cannot be generated as
             * it's impossible to tell how the data points should be broadcasted
             * or associated to each one of the samples to be generated.
             *
             * @param num_samples: number of samples to be generated
             */
            void check_data(int num_samples) const;

            /**
             * Creates a tensor of dimensions (sample_size, num_samples, time_steps) for each
             * one of the latent nodes in the model and adds it to the
             * node_lable_to_samples mapping.
             *
             * @param num_samples: number of samples to generate
             * @param time_steps: number of time steps the model will be
             * unrolled into
             */
            void init_samples_tensor(int num_samples, int time_steps);

            /**
             * Samples a value from a node's CPD and set it as the node's
             * assignment.
             *
             * @param node: Random variable node
             */
            void update_assignment_from_sample(
                std::shared_ptr<RandomVariableNode> node);
        };
    } // namespace model
} // namespace tomcat