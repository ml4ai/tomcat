#pragma once

#include "DynamicBayesNet.h"
#include <eigen3/Eigen/Dense>
#include <memory>
#include <string>
#include <unordered_map>
#include <unordered_set>

namespace tomcat {
    namespace model {

        /**
         * Abstract representation of a class to generate samples from a DBN
         * model.
         */
        class Sampler {

          protected:
            std::shared_ptr<gsl_rng> random_generator;
            DynamicBayesNet model;

            // Mapping between node's label and data (observed values over
            // time). The data matrix has dimension (num_datapoints,
            // num_time_steps, sample_size).
            std::unordered_map<std::string, Eigen::MatrixXd> node_to_data;

            // Mapping between node's label and samples generated by a sampler.
            // The samples matrix has dimension (num_samples, num_time_steps,
            // sample_size).
            std::unordered_map<std::string, Eigen::MatrixXd> node_to_samples;

            // Nodes which values are not observed, i.e., nodes samples will be
            // generated for.
            std::unordered_set<std::string> latent_node_labels;

            /**
             * Check whether the number of datapoints is consistent with the
             * number of samples. If there's a single datapoint, then it's value
             * is going to be considered in all the samples generated. If
             * there's as many datapoints as the number of samples requested,
             * then for each new sample, a new datapoint will be considered.
             * Otherwise, samples cannot be generated as it's impossible to tell
             * how the datapoints should be broadcasted or associated to each
             * one of the samples to be generated.
             *
             * @param num_samples: number of samples to be generated
             */
            void check_data(int num_samples) const;

            /**
             * Create a matrix of dimension (num_samples, time_steps) for each
             * one of the latent nodes in the model and add it to the
             * node_to_samples mapping.
             *
             * @param num_samples: number of samples to generate
             * @param time_steps: number of time steps the model will be
             * unrolled into
             */
            void init_samples_matrix(int num_samples, int time_steps);

          public:
            Sampler() {}
            Sampler(DynamicBayesNet model,
                    std::shared_ptr<gsl_rng> random_generator);
            virtual ~Sampler() {}

            // Copy constructor and assignment should be deleted to avoid
            // implicit slicing and loss of polymorphic behaviour in the
            // subclasses. To deep copy, the clone method must be used.
            Sampler(const Sampler&) = delete;
            Sampler& operator=(const Sampler&) = delete;
            Sampler(Sampler&&) = default;
            Sampler& operator=(Sampler&&) = default;

            /**
             * Adds data to a specific node.
             *
             * @param node_label: node's label
             * @param data: observed values for the node
             */
            void add_data(std::string& node_label, Eigen::MatrixXd& data);

            /**
             * Adds data to a specific node.
             *
             * @param node_label: node's label
             * @param data: observed values for the node
             */
            void add_data(std::string&& node_label, Eigen::MatrixXd&& data);

            /**
             * Return samples generated for a specific latent node
             *
             * @param node_label: latent node label
             * @return Samples
             */
            const Eigen::MatrixXd&
            get_samples(const std::string& node_label) const;

            /**
             * Generate samples for the latent nodes
             *
             * @param num_samples: number of samples to generate
             * @param time_steps: number of time steps the model should be
             * unrolled into
             */
            virtual void sample(int num_samples, int time_steps) = 0;

            /**
             * Clone sampler
             *
             * @return Pointer to the new node
             */
            virtual std::unique_ptr<Sampler> clone() = 0;
        };
    } // namespace model
} // namespace tomcat