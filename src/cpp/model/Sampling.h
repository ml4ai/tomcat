#pragma once
#include "DynamicBayesNet.h"
#include <eigen3/Eigen/Dense>
#include <string>
#include <unordered_map>
#include <unordered_set>

namespace tomcat {
    namespace model {

        class Sampling {

          private:
            DynamicBayesNet model;

            // Mapping between node's label and data (observed values over
            // time). The data matrix has dimension (num_datapoints,
            // num_time_steps, sample_size).
            std::unordered_map<std::string, Eigen::MatrixXd> node_to_data;

            // Mapping between node's label and samples generated by a sampler.
            // The samples matrix has dimension (num_samples, num_time_steps,
            // sample_size).
            std::unordered_map<std::string, Eigen::MatrixXd> node_to_samples;

            // Nodes which values are not observed, i.e., nodes samples will be
            // generated for.
            std::unordered_set<std::string> latent_node_labels;

          public:
            Sampling(DynamicBayesNet model) : model(model) {
                for (auto& node : model.get_nodes()) {
                    this->latent_nodes.insert(node.get_metadata()->get_label());
                }
            }
            virtual ~Sampling() {}

            Sampling(const Sampling&) = delete;
            Sampling& operator=(const Sampling&) = delete;
            Sampling(Sampling&&) = default;
            Sampling& operator=(Sampling&&) = default;

            /**
             * Adds data to a specific node.
             *
             * @param node_label: node's label
             * @param data: observed values for the node
             */
            void add_data(std::string& node_label, Eigen::MatrixXd& data) {
                this->node_to_data[node_label] = data;
                this->latent_node_labels.erase(node_label);
            }
            void add_data(std::string&& node_label, Eigen::MatrixXd&& data) {
                this->node_to_data[node_label] = std::move(data);
                this->latent_node_labels.erase(node_label);
            }
            const Eigen::MatrixXd& get_samples(std::string node_label) const {
                return this->node_to_samples[node_label];
            }

            virtual void sample(int num_samples, int time_steps) = 0;
        };
    } // namespace model
} // namespace tomcat