#pragma once

#include "sampling/Sampler.h"

#include "utils/Definitions.h"

namespace tomcat {
    namespace model {

        /**
         * Generates samples by Gibbs sampling process. First, samples are
         * generated for data nodes (non-parameter nodes) from the roots to the
         * leaves. Samples values from these nodes are propagated as sufficient
         * statistics to parameter nodes they depend on. Next, parameter nodes
         * are sampled from their posterior formed by it's conjugate prior
         * updated by the sufficient statistics previously propagated by the
         * data nodes.
         *
         */
        class GibbsSampler : public Sampler {
          public:
            //------------------------------------------------------------------
            // Constructors & Destructor
            //------------------------------------------------------------------

            /**
             * Creates an instance of the sampler for a given model and random
             * number generator.
             *
             * @param model: DBN
             */
            GibbsSampler(std::shared_ptr<DynamicBayesNet> model,
                         int burn_in_period);

            ~GibbsSampler();

            //------------------------------------------------------------------
            // Copy & Move constructors/assignments
            //------------------------------------------------------------------
            GibbsSampler(const GibbsSampler& sampler);

            GibbsSampler& operator=(const GibbsSampler& sampler);

            GibbsSampler(GibbsSampler&&) = default;

            GibbsSampler& operator=(GibbsSampler&&) = default;

            //------------------------------------------------------------------
            // Member functions
            //------------------------------------------------------------------
            void sample_latent(std::shared_ptr<gsl_rng> random_generator,
                               int num_samples) override;

            Tensor3
            get_samples(const std::string& node_label) const override;

            void get_info(nlohmann::json& json) const override;

          protected:
            //------------------------------------------------------------------
            // Member functions
            //------------------------------------------------------------------
            void copy_sampler(const GibbsSampler& sampler);

          private:
            //------------------------------------------------------------------
            // Member functions
            //------------------------------------------------------------------

            /**
             * Populates the nodes' assignments with initial values.
             *
             * @param random_generator: random number generator
             */
            void
            fill_initial_samples(std::shared_ptr<gsl_rng> random_generator);

            /**
             * Initialize tensors to store the samples generated by the latent
             * nodes.
             *
             * @param num_samples: number of samples to generate
             * @param latent_nodes: nodes which samples will be generated for
             */
            void init_samples_storage(
                int num_samples,
                std::vector<std::shared_ptr<Node>> latent_nodes);

            /**
             * Samples from the posterior distribution of a data node
             * (non-parameter latent node). The posterior for a data node x is
             * given by P(x|Pa(x))P(Ch1(x)|x)...P(Chk(x)|x), where Pa(x) is the
             * parents of x and Chi(x) is the i-th child of x. P(Chi(x)|x) is a
             * vector containing the pdf of the current value assigned to the
             * i-th child f x for each one of the possible values x can take.
             *
             * @param random_generator: random number generator
             * @param node: data node
             * @param discard: indicates whether the sample should be discarded
             * or stored
             */
            void sample_data_node(std::shared_ptr<gsl_rng> random_generator,
                                  std::shared_ptr<Node> node,
                                  bool discard);

            /**
             * Samples from the posterior distribution of a parameter node. The
             * posterior for a parameter node is given by its prior adjusted by
             * some sufficient statistics. For instance, if a parameter node has
             * a Dirichlet distribution as prior, its posterior will be a
             * Dirichlet with the coefficients updated according to the sampled
             * values of the data nodes that depend on this parameter. As data
             * nodes are sampled from the roots to the leaves, their sampled
             * values are informed to the parameter nodes they depend on so they
             * can update its sufficient statistics so as to avoid looping over
             * data nodes when sampling a parameter node. It only works with
             * conjugate priors.
             *
             * @param random_generator: random number generator
             * @param node: parameter node
             * @param discard: indicates whether the sample should be discarded
             * or stored
             */
            void
            sample_parameter_node(std::shared_ptr<gsl_rng> random_generator,
                                  std::shared_ptr<Node> node,
                                  bool discard);

            /**
             * Returns the weights for a given node given by the product of the
             * pdfs of all of its children's assignments given all possible
             * node's assignments. It can be a matrix because child nodes can
             * have multiple assignments.
             *
             * @param node: node to compute the weights for
             */
            Eigen::MatrixXd get_weights_for(const std::shared_ptr<Node>& node);

            /**
             * Stores a new sample in the local samples' container.
             *
             * @param node: Node which the sample was generated for
             * @param sample: Sampled value
             */
            void keep_sample(const std::shared_ptr<RandomVariableNode>& node,
                             const Eigen::MatrixXd& sample);

            /**
             * Reset samples counter and storage
             */
            void reset();

            //------------------------------------------------------------------
            // Data members
            //------------------------------------------------------------------
            int burn_in_period = 0;

            // Container to store the samples generated by this sampler.
            // Different from the Ancestral sampler, where the generated samples
            // are store as nodes' assignments, in the Gibbs sampler, for each
            // latent node, one sample is generate at a time and kept as that
            // node's assignment until the next round. Another structure is then
            // needed to stored the samples that were generated along the
            // process.
            std::unordered_map<std::string, Tensor3> node_label_to_samples;

            int iteration = 0;
        };

    } // namespace model
} // namespace tomcat
