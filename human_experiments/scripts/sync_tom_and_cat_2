#!/bin/bash 

##############################################################################
#
# Identification:
#     Support script for script sync_tom_and_cat.
#
# Description:
#     See sync_tom_and_cat.
#
# Output:
#     All output goes to stdout for sync_tom_and_cat to do with it what it will. 
#
# Exit status:
#     Following unix convention, this script exits with 0 on success, and
#     non-zero if there was an error. 
#
# Author:
#     Kobus Barnard
#
##############################################################################

set -u

# Our exit status will be that of the last command that failed. 
exit_status=0

# The initial commands in this script executes need to succeed, so we can
# simplify error handling to trap failures to report them, and then ask bash to
# exit. But until then we simply have to die. 
set -e

# Revoke possible removal of group perms (if we are running as root) and don't
# permit others any access. 
umask 0007 

data="/data"
# For testing. 
# data="${TOMCAT_DIR}/data"

# Must have trailing slashes for rsync (and paths must be devoid of spaces).
sensor_data_dir="${data}/cat/LangLab/experiments/"
sensor_mirror_dir="${data}/tom/LangLab/experiments/"

# Generic error reporting for basic commands
trap 'exit_status=$?;
      echo 
      echo TRP: Command on or near line $LINENO of $0 failed with status $exit_status 
      #
      # Record time in case we need to map issues to system logs. 
      #
      echo TRP: Time $(date)
      #
      echo RAW: $BASH_COMMAND
      #
      # The following naive parsing and eval assumes a limited number of cases
      # of commands, all of which are in this file. In other words, this is OK,
      # since all failures should be tested.
      # 
      clean_cmd=$(echo ${BASH_COMMAND} | sed "s/2>.*//")
      # echo CMD: ${clean_cmd} 1>&2;
      #
      # Extract command from a=$(b).`
      clean_cmd=$(echo ${clean_cmd} | sed "s/.*=\$(\(.*\))$/\1/")
      #
      eval echo EXP: ${clean_cmd}
      echo ' ERR

date_stamp=$(date +%y-%m-%d-%H-%M) 2>&1
backup_suffix="-RSYNC-${date_stamp}"

mkdir -p "${sensor_data_dir}"  2>&1
mkdir -p "${sensor_mirror_dir}"  2>&1 

# We initially used '-a' which means '-rlptgoD', but setting ownership (-o) or
# group (-g) on cross-mounted disks can cause breakage, and we do not need it.
# Also, it seems desirable to preserve create times ('-N' or '--crtimes') as we
# might need this as an emergency data time stamp, but this does not work,
# possibly due to rsync, possibly due to the OS (whether or not the OS can
# change a create time is not universal, and debatable as desirable, but Kobus
# uses it on ocasion).
#
### rsync_options="-a -u -b --suffix ${backup_suffix}"
### rsync_options="-rlptgD --crtimes -u -b --suffix ${backup_suffix}"
# 
# These options are causing grief. Despite preserving time and having a generous
# modify-window, we will still create backups of files that have not changed.
# Take a bit more risk to go faster and suffer less grief. 
# rsync_options="-rlptD -u -b --suffix ${backup_suffix} --modify-window=10"
#
rsync_options="-rlptD -u --size-only"

if [[ "${IVI_VERBOSE}" != "0" ]]; then
    rsync_options="-v ${rsync_options}"
fi 

if [[ "${IVI_VERBOSE_2}" != "0" ]]; then
    rsync_options="-v ${rsync_options}"
fi 

if [[ "${IVI_VERBOSE_3}" != "0" ]]; then
    rsync_options="-v ${rsync_options}"
fi 

# If we get this far, there may be some value of doing subsequent rsyncs even if
# previous ones failed. 
set +e 

# If we need to reverse cat and tom, then we need to reverse sensor_data_dir and
# sensor_mirror_dir above. We originally did three syncs to, from and to, which
# gives a true mirror including backup files, but this is too slow and unwieldy,
# and not necessary as we now are pulling data regularly. 
#

${VERBOSE_ECHO} "Sync_tom_and_cat_2 executing rsync"
${VERBOSE_ECHO} "    rsync ${rsync_options} ${sensor_data_dir} ${sensor_mirror_dir}"
${VERBOSE_ECHO} ""

rsync ${rsync_options} ${sensor_data_dir} ${sensor_mirror_dir} 2>&1
rc=$?
${VERBOSE_ECHO} "Rsync return code was ${rc}"
${VERBOSE_ECHO} "Pending exit status is ${exit_status}"
${VERBOSE_ECHO} ""

# Now OBSOLETE
#
# ${VERBOSE_ECHO} "Sync_tom_and_cat_2 executing second rsync"
# ${VERBOSE_ECHO} "    rsync {rsync_options} ${sensor_mirror_dir} ${sensor_data_dir}"
# ${VERBOSE_ECHO} ""
# 
# rsync ${rsync_options} ${sensor_mirror_dir} ${sensor_data_dir} 2>&1
# rc=$?
# ${VERBOSE_ECHO} "Rsync return code was ${rc}"
# ${VERBOSE_ECHO} "Pending exit status is ${exit_status}"
# ${VERBOSE_ECHO} ""
# 
# ${VERBOSE_ECHO} "Pending exit status is ${exit_status}"
# ${VERBOSE_ECHO} ""
# 
# # Redo the first rsync to make sure we synchronize any backups that the second
# # rsync created. 
# #
# ${VERBOSE_ECHO} "Sync_tom_and_cat_2 executing third rsync"
# ${VERBOSE_ECHO} "    ${rsync_options} ${sensor_data_dir} ${sensor_mirror_dir}"
# ${VERBOSE_ECHO} ""
# 
# rsync ${rsync_options} ${sensor_data_dir} ${sensor_mirror_dir} 2>&1
# rc=$?
# ${VERBOSE_ECHO} "Rsync return code was ${rc}"
# ${VERBOSE_ECHO} "Pending exit status is ${exit_status}"
# ${VERBOSE_ECHO} ""
# 
# ${VERBOSE_ECHO} "Pending exit status is ${exit_status}"
# ${VERBOSE_ECHO} ""

exit ${exit_status}


